{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = is;\nvar _shallowEqual = require(\"../utils/shallowEqual\");\nvar _isType = require(\"./isType\");\nvar _isPlaceholderType = require(\"./isPlaceholderType\");\nvar _definitions = require(\"../definitions\");\nfunction is(type, node, opts) {\n  if (!node) return false;\n  const matches = (0, _isType.default)(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in _definitions.FLIPPED_ALIAS_KEYS) {\n      return (0, _isPlaceholderType.default)(node.expectedNode, type);\n    }\n    return false;\n  }\n  if (typeof opts === \"undefined\") {\n    return true;\n  } else {\n    return (0, _shallowEqual.default)(node, opts);\n  }\n}","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AACA;AACA;AA8Be,SAASA,EAAE,CACxBC,IAAY,EACZC,IAA+B,EAC/BC,IAAsB,EACN;EAChB,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,MAAME,OAAO,GAAG,mBAAM,EAACF,IAAI,CAACD,IAAI,EAAEA,IAAI,CAAC;EACvC,IAAI,CAACG,OAAO,EAAE;IACZ,IAAI,CAACD,IAAI,IAAID,IAAI,CAACD,IAAI,KAAK,aAAa,IAAIA,IAAI,IAAII,+BAAkB,EAAE;MAUtE,OAAO,8BAAiB,EAACH,IAAI,CAACI,YAAY,EAAEL,IAAI,CAAC;IACnD;IACA,OAAO,KAAK;EACd;EAEA,IAAI,OAAOE,IAAI,KAAK,WAAW,EAAE;IAC/B,OAAO,IAAI;EACb,CAAC,MAAM;IACL,OAAO,yBAAY,EAACD,IAAI,EAAEC,IAAI,CAAC;EACjC;AACF","names":["is","type","node","opts","matches","FLIPPED_ALIAS_KEYS","expectedNode"],"sources":["/home/charlotte/WebApplicationProject/node_modules/@babel/types/src/validators/is.ts"],"sourcesContent":["import shallowEqual from \"../utils/shallowEqual\";\nimport isType from \"./isType\";\nimport isPlaceholderType from \"./isPlaceholderType\";\nimport { FLIPPED_ALIAS_KEYS } from \"../definitions\";\nimport type * as t from \"..\";\n\nexport default function is<T extends t.Node[\"type\"]>(\n  type: T,\n  node: t.Node | null | undefined,\n  opts?: undefined,\n): node is Extract<t.Node, { type: T }>;\n\nexport default function is<\n  T extends t.Node[\"type\"],\n  P extends Extract<t.Node, { type: T }>,\n>(type: T, n: t.Node | null | undefined, required: Partial<P>): n is P;\n\nexport default function is<P extends t.Node>(\n  type: string,\n  node: t.Node | null | undefined,\n  opts: Partial<P>,\n): node is P;\n\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node;\n/**\n * Returns whether `node` is of given `type`.\n *\n * For better performance, use this instead of `is[Type]` when `type` is unknown.\n */\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node {\n  if (!node) return false;\n\n  const matches = isType(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in FLIPPED_ALIAS_KEYS) {\n      // We can only return true if the placeholder doesn't replace a real node,\n      // but it replaces a category of nodes (an alias).\n      //\n      // t.is(\"Identifier\", node) gives some guarantees about node's shape, so we\n      // can't say that Placeholder(expectedNode: \"Identifier\") is an identifier\n      // because it doesn't have the same properties.\n      // On the other hand, t.is(\"Expression\", node) doesn't say anything about\n      // the shape of node because Expression can be many different nodes: we can,\n      // and should, safely report expression placeholders as Expressions.\n      return isPlaceholderType(node.expectedNode, type);\n    }\n    return false;\n  }\n\n  if (typeof opts === \"undefined\") {\n    return true;\n  } else {\n    return shallowEqual(node, opts);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}