{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _generated = require(\"../validators/generated\");\nvar _generated2 = require(\"../builders/generated\");\nvar _default = toStatement;\nexports.default = _default;\nfunction toStatement(node, ignore) {\n  if ((0, _generated.isStatement)(node)) {\n    return node;\n  }\n  let mustHaveId = false;\n  let newType;\n  if ((0, _generated.isClass)(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if ((0, _generated.isFunction)(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if ((0, _generated.isAssignmentExpression)(node)) {\n    return (0, _generated2.expressionStatement)(node);\n  }\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n  node.type = newType;\n  return node;\n}","map":{"version":3,"mappings":";;;;;;AAAA;AAMA;AAA4D,eAG7CA,WAAW;AAAAC;AAgB1B,SAASD,WAAW,CAACE,IAAY,EAAEC,MAAgB,EAAuB;EACxE,IAAI,0BAAW,EAACD,IAAI,CAAC,EAAE;IACrB,OAAOA,IAAI;EACb;EAEA,IAAIE,UAAU,GAAG,KAAK;EACtB,IAAIC,OAAO;EAEX,IAAI,sBAAO,EAACH,IAAI,CAAC,EAAE;IACjBE,UAAU,GAAG,IAAI;IACjBC,OAAO,GAAG,kBAA2B;EACvC,CAAC,MAAM,IAAI,yBAAU,EAACH,IAAI,CAAC,EAAE;IAC3BE,UAAU,GAAG,IAAI;IACjBC,OAAO,GAAG,qBAA8B;EAC1C,CAAC,MAAM,IAAI,qCAAsB,EAACH,IAAI,CAAC,EAAE;IACvC,OAAO,mCAAmB,EAACA,IAAI,CAAC;EAClC;EAGA,IAAIE,UAAU,IAAI,CAACF,IAAI,CAACI,EAAE,EAAE;IAC1BD,OAAO,GAAG,KAAc;EAC1B;EAEA,IAAI,CAACA,OAAO,EAAE;IACZ,IAAIF,MAAM,EAAE;MACV,OAAO,KAAK;IACd,CAAC,MAAM;MACL,MAAM,IAAII,KAAK,CAAE,eAAcL,IAAI,CAACM,IAAK,iBAAgB,CAAC;IAC5D;EACF;EAGAN,IAAI,CAACM,IAAI,GAAGH,OAAO;EAGnB,OAAOH,IAAI;AACb","names":["toStatement","exports","node","ignore","mustHaveId","newType","id","Error","type"],"sources":["/home/charlotte/WebApplicationProject/node_modules/@babel/types/src/converters/toStatement.ts"],"sourcesContent":["import {\n  isStatement,\n  isFunction,\n  isClass,\n  isAssignmentExpression,\n} from \"../validators/generated\";\nimport { expressionStatement } from \"../builders/generated\";\nimport type * as t from \"..\";\n\nexport default toStatement as {\n  (node: t.AssignmentExpression, ignore?: boolean): t.ExpressionStatement;\n\n  <T extends t.Statement>(node: T, ignore: false): T;\n  <T extends t.Statement>(node: T, ignore?: boolean): T | false;\n\n  (node: t.Class, ignore: false): t.ClassDeclaration;\n  (node: t.Class, ignore?: boolean): t.ClassDeclaration | false;\n\n  (node: t.Function, ignore: false): t.FunctionDeclaration;\n  (node: t.Function, ignore?: boolean): t.FunctionDeclaration | false;\n\n  (node: t.Node, ignore: false): t.Statement;\n  (node: t.Node, ignore?: boolean): t.Statement | false;\n};\n\nfunction toStatement(node: t.Node, ignore?: boolean): t.Statement | false {\n  if (isStatement(node)) {\n    return node;\n  }\n\n  let mustHaveId = false;\n  let newType;\n\n  if (isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\" as const;\n  } else if (isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\" as const;\n  } else if (isAssignmentExpression(node)) {\n    return expressionStatement(node);\n  }\n\n  // @ts-expect-error todo(flow->ts): node.id might be missing\n  if (mustHaveId && !node.id) {\n    newType = false as false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n\n  // @ts-expect-error manipulating node.type\n  node.type = newType;\n\n  // @ts-expect-error todo(flow->ts) refactor to avoid type unsafe mutations like reassigning node type above\n  return node;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}