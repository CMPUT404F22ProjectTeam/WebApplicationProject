{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isAccessor = isAccessor;\nexports.isAnyTypeAnnotation = isAnyTypeAnnotation;\nexports.isArgumentPlaceholder = isArgumentPlaceholder;\nexports.isArrayExpression = isArrayExpression;\nexports.isArrayPattern = isArrayPattern;\nexports.isArrayTypeAnnotation = isArrayTypeAnnotation;\nexports.isArrowFunctionExpression = isArrowFunctionExpression;\nexports.isAssignmentExpression = isAssignmentExpression;\nexports.isAssignmentPattern = isAssignmentPattern;\nexports.isAwaitExpression = isAwaitExpression;\nexports.isBigIntLiteral = isBigIntLiteral;\nexports.isBinary = isBinary;\nexports.isBinaryExpression = isBinaryExpression;\nexports.isBindExpression = isBindExpression;\nexports.isBlock = isBlock;\nexports.isBlockParent = isBlockParent;\nexports.isBlockStatement = isBlockStatement;\nexports.isBooleanLiteral = isBooleanLiteral;\nexports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\nexports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\nexports.isBreakStatement = isBreakStatement;\nexports.isCallExpression = isCallExpression;\nexports.isCatchClause = isCatchClause;\nexports.isClass = isClass;\nexports.isClassAccessorProperty = isClassAccessorProperty;\nexports.isClassBody = isClassBody;\nexports.isClassDeclaration = isClassDeclaration;\nexports.isClassExpression = isClassExpression;\nexports.isClassImplements = isClassImplements;\nexports.isClassMethod = isClassMethod;\nexports.isClassPrivateMethod = isClassPrivateMethod;\nexports.isClassPrivateProperty = isClassPrivateProperty;\nexports.isClassProperty = isClassProperty;\nexports.isCompletionStatement = isCompletionStatement;\nexports.isConditional = isConditional;\nexports.isConditionalExpression = isConditionalExpression;\nexports.isContinueStatement = isContinueStatement;\nexports.isDebuggerStatement = isDebuggerStatement;\nexports.isDecimalLiteral = isDecimalLiteral;\nexports.isDeclaration = isDeclaration;\nexports.isDeclareClass = isDeclareClass;\nexports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\nexports.isDeclareExportDeclaration = isDeclareExportDeclaration;\nexports.isDeclareFunction = isDeclareFunction;\nexports.isDeclareInterface = isDeclareInterface;\nexports.isDeclareModule = isDeclareModule;\nexports.isDeclareModuleExports = isDeclareModuleExports;\nexports.isDeclareOpaqueType = isDeclareOpaqueType;\nexports.isDeclareTypeAlias = isDeclareTypeAlias;\nexports.isDeclareVariable = isDeclareVariable;\nexports.isDeclaredPredicate = isDeclaredPredicate;\nexports.isDecorator = isDecorator;\nexports.isDirective = isDirective;\nexports.isDirectiveLiteral = isDirectiveLiteral;\nexports.isDoExpression = isDoExpression;\nexports.isDoWhileStatement = isDoWhileStatement;\nexports.isEmptyStatement = isEmptyStatement;\nexports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\nexports.isEnumBody = isEnumBody;\nexports.isEnumBooleanBody = isEnumBooleanBody;\nexports.isEnumBooleanMember = isEnumBooleanMember;\nexports.isEnumDeclaration = isEnumDeclaration;\nexports.isEnumDefaultedMember = isEnumDefaultedMember;\nexports.isEnumMember = isEnumMember;\nexports.isEnumNumberBody = isEnumNumberBody;\nexports.isEnumNumberMember = isEnumNumberMember;\nexports.isEnumStringBody = isEnumStringBody;\nexports.isEnumStringMember = isEnumStringMember;\nexports.isEnumSymbolBody = isEnumSymbolBody;\nexports.isExistsTypeAnnotation = isExistsTypeAnnotation;\nexports.isExportAllDeclaration = isExportAllDeclaration;\nexports.isExportDeclaration = isExportDeclaration;\nexports.isExportDefaultDeclaration = isExportDefaultDeclaration;\nexports.isExportDefaultSpecifier = isExportDefaultSpecifier;\nexports.isExportNamedDeclaration = isExportNamedDeclaration;\nexports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\nexports.isExportSpecifier = isExportSpecifier;\nexports.isExpression = isExpression;\nexports.isExpressionStatement = isExpressionStatement;\nexports.isExpressionWrapper = isExpressionWrapper;\nexports.isFile = isFile;\nexports.isFlow = isFlow;\nexports.isFlowBaseAnnotation = isFlowBaseAnnotation;\nexports.isFlowDeclaration = isFlowDeclaration;\nexports.isFlowPredicate = isFlowPredicate;\nexports.isFlowType = isFlowType;\nexports.isFor = isFor;\nexports.isForInStatement = isForInStatement;\nexports.isForOfStatement = isForOfStatement;\nexports.isForStatement = isForStatement;\nexports.isForXStatement = isForXStatement;\nexports.isFunction = isFunction;\nexports.isFunctionDeclaration = isFunctionDeclaration;\nexports.isFunctionExpression = isFunctionExpression;\nexports.isFunctionParent = isFunctionParent;\nexports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\nexports.isFunctionTypeParam = isFunctionTypeParam;\nexports.isGenericTypeAnnotation = isGenericTypeAnnotation;\nexports.isIdentifier = isIdentifier;\nexports.isIfStatement = isIfStatement;\nexports.isImmutable = isImmutable;\nexports.isImport = isImport;\nexports.isImportAttribute = isImportAttribute;\nexports.isImportDeclaration = isImportDeclaration;\nexports.isImportDefaultSpecifier = isImportDefaultSpecifier;\nexports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\nexports.isImportSpecifier = isImportSpecifier;\nexports.isIndexedAccessType = isIndexedAccessType;\nexports.isInferredPredicate = isInferredPredicate;\nexports.isInterfaceDeclaration = isInterfaceDeclaration;\nexports.isInterfaceExtends = isInterfaceExtends;\nexports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;\nexports.isInterpreterDirective = isInterpreterDirective;\nexports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\nexports.isJSX = isJSX;\nexports.isJSXAttribute = isJSXAttribute;\nexports.isJSXClosingElement = isJSXClosingElement;\nexports.isJSXClosingFragment = isJSXClosingFragment;\nexports.isJSXElement = isJSXElement;\nexports.isJSXEmptyExpression = isJSXEmptyExpression;\nexports.isJSXExpressionContainer = isJSXExpressionContainer;\nexports.isJSXFragment = isJSXFragment;\nexports.isJSXIdentifier = isJSXIdentifier;\nexports.isJSXMemberExpression = isJSXMemberExpression;\nexports.isJSXNamespacedName = isJSXNamespacedName;\nexports.isJSXOpeningElement = isJSXOpeningElement;\nexports.isJSXOpeningFragment = isJSXOpeningFragment;\nexports.isJSXSpreadAttribute = isJSXSpreadAttribute;\nexports.isJSXSpreadChild = isJSXSpreadChild;\nexports.isJSXText = isJSXText;\nexports.isLVal = isLVal;\nexports.isLabeledStatement = isLabeledStatement;\nexports.isLiteral = isLiteral;\nexports.isLogicalExpression = isLogicalExpression;\nexports.isLoop = isLoop;\nexports.isMemberExpression = isMemberExpression;\nexports.isMetaProperty = isMetaProperty;\nexports.isMethod = isMethod;\nexports.isMiscellaneous = isMiscellaneous;\nexports.isMixedTypeAnnotation = isMixedTypeAnnotation;\nexports.isModuleDeclaration = isModuleDeclaration;\nexports.isModuleExpression = isModuleExpression;\nexports.isModuleSpecifier = isModuleSpecifier;\nexports.isNewExpression = isNewExpression;\nexports.isNoop = isNoop;\nexports.isNullLiteral = isNullLiteral;\nexports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\nexports.isNullableTypeAnnotation = isNullableTypeAnnotation;\nexports.isNumberLiteral = isNumberLiteral;\nexports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\nexports.isNumberTypeAnnotation = isNumberTypeAnnotation;\nexports.isNumericLiteral = isNumericLiteral;\nexports.isObjectExpression = isObjectExpression;\nexports.isObjectMember = isObjectMember;\nexports.isObjectMethod = isObjectMethod;\nexports.isObjectPattern = isObjectPattern;\nexports.isObjectProperty = isObjectProperty;\nexports.isObjectTypeAnnotation = isObjectTypeAnnotation;\nexports.isObjectTypeCallProperty = isObjectTypeCallProperty;\nexports.isObjectTypeIndexer = isObjectTypeIndexer;\nexports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;\nexports.isObjectTypeProperty = isObjectTypeProperty;\nexports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\nexports.isOpaqueType = isOpaqueType;\nexports.isOptionalCallExpression = isOptionalCallExpression;\nexports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;\nexports.isOptionalMemberExpression = isOptionalMemberExpression;\nexports.isParenthesizedExpression = isParenthesizedExpression;\nexports.isPattern = isPattern;\nexports.isPatternLike = isPatternLike;\nexports.isPipelineBareFunction = isPipelineBareFunction;\nexports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;\nexports.isPipelineTopicExpression = isPipelineTopicExpression;\nexports.isPlaceholder = isPlaceholder;\nexports.isPrivate = isPrivate;\nexports.isPrivateName = isPrivateName;\nexports.isProgram = isProgram;\nexports.isProperty = isProperty;\nexports.isPureish = isPureish;\nexports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\nexports.isRecordExpression = isRecordExpression;\nexports.isRegExpLiteral = isRegExpLiteral;\nexports.isRegexLiteral = isRegexLiteral;\nexports.isRestElement = isRestElement;\nexports.isRestProperty = isRestProperty;\nexports.isReturnStatement = isReturnStatement;\nexports.isScopable = isScopable;\nexports.isSequenceExpression = isSequenceExpression;\nexports.isSpreadElement = isSpreadElement;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStandardized = isStandardized;\nexports.isStatement = isStatement;\nexports.isStaticBlock = isStaticBlock;\nexports.isStringLiteral = isStringLiteral;\nexports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\nexports.isStringTypeAnnotation = isStringTypeAnnotation;\nexports.isSuper = isSuper;\nexports.isSwitchCase = isSwitchCase;\nexports.isSwitchStatement = isSwitchStatement;\nexports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;\nexports.isTSAnyKeyword = isTSAnyKeyword;\nexports.isTSArrayType = isTSArrayType;\nexports.isTSAsExpression = isTSAsExpression;\nexports.isTSBaseType = isTSBaseType;\nexports.isTSBigIntKeyword = isTSBigIntKeyword;\nexports.isTSBooleanKeyword = isTSBooleanKeyword;\nexports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\nexports.isTSConditionalType = isTSConditionalType;\nexports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\nexports.isTSConstructorType = isTSConstructorType;\nexports.isTSDeclareFunction = isTSDeclareFunction;\nexports.isTSDeclareMethod = isTSDeclareMethod;\nexports.isTSEntityName = isTSEntityName;\nexports.isTSEnumDeclaration = isTSEnumDeclaration;\nexports.isTSEnumMember = isTSEnumMember;\nexports.isTSExportAssignment = isTSExportAssignment;\nexports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\nexports.isTSExternalModuleReference = isTSExternalModuleReference;\nexports.isTSFunctionType = isTSFunctionType;\nexports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\nexports.isTSImportType = isTSImportType;\nexports.isTSIndexSignature = isTSIndexSignature;\nexports.isTSIndexedAccessType = isTSIndexedAccessType;\nexports.isTSInferType = isTSInferType;\nexports.isTSInstantiationExpression = isTSInstantiationExpression;\nexports.isTSInterfaceBody = isTSInterfaceBody;\nexports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\nexports.isTSIntersectionType = isTSIntersectionType;\nexports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;\nexports.isTSLiteralType = isTSLiteralType;\nexports.isTSMappedType = isTSMappedType;\nexports.isTSMethodSignature = isTSMethodSignature;\nexports.isTSModuleBlock = isTSModuleBlock;\nexports.isTSModuleDeclaration = isTSModuleDeclaration;\nexports.isTSNamedTupleMember = isTSNamedTupleMember;\nexports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\nexports.isTSNeverKeyword = isTSNeverKeyword;\nexports.isTSNonNullExpression = isTSNonNullExpression;\nexports.isTSNullKeyword = isTSNullKeyword;\nexports.isTSNumberKeyword = isTSNumberKeyword;\nexports.isTSObjectKeyword = isTSObjectKeyword;\nexports.isTSOptionalType = isTSOptionalType;\nexports.isTSParameterProperty = isTSParameterProperty;\nexports.isTSParenthesizedType = isTSParenthesizedType;\nexports.isTSPropertySignature = isTSPropertySignature;\nexports.isTSQualifiedName = isTSQualifiedName;\nexports.isTSRestType = isTSRestType;\nexports.isTSSatisfiesExpression = isTSSatisfiesExpression;\nexports.isTSStringKeyword = isTSStringKeyword;\nexports.isTSSymbolKeyword = isTSSymbolKeyword;\nexports.isTSThisType = isTSThisType;\nexports.isTSTupleType = isTSTupleType;\nexports.isTSType = isTSType;\nexports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\nexports.isTSTypeAnnotation = isTSTypeAnnotation;\nexports.isTSTypeAssertion = isTSTypeAssertion;\nexports.isTSTypeElement = isTSTypeElement;\nexports.isTSTypeLiteral = isTSTypeLiteral;\nexports.isTSTypeOperator = isTSTypeOperator;\nexports.isTSTypeParameter = isTSTypeParameter;\nexports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\nexports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\nexports.isTSTypePredicate = isTSTypePredicate;\nexports.isTSTypeQuery = isTSTypeQuery;\nexports.isTSTypeReference = isTSTypeReference;\nexports.isTSUndefinedKeyword = isTSUndefinedKeyword;\nexports.isTSUnionType = isTSUnionType;\nexports.isTSUnknownKeyword = isTSUnknownKeyword;\nexports.isTSVoidKeyword = isTSVoidKeyword;\nexports.isTaggedTemplateExpression = isTaggedTemplateExpression;\nexports.isTemplateElement = isTemplateElement;\nexports.isTemplateLiteral = isTemplateLiteral;\nexports.isTerminatorless = isTerminatorless;\nexports.isThisExpression = isThisExpression;\nexports.isThisTypeAnnotation = isThisTypeAnnotation;\nexports.isThrowStatement = isThrowStatement;\nexports.isTopicReference = isTopicReference;\nexports.isTryStatement = isTryStatement;\nexports.isTupleExpression = isTupleExpression;\nexports.isTupleTypeAnnotation = isTupleTypeAnnotation;\nexports.isTypeAlias = isTypeAlias;\nexports.isTypeAnnotation = isTypeAnnotation;\nexports.isTypeCastExpression = isTypeCastExpression;\nexports.isTypeParameter = isTypeParameter;\nexports.isTypeParameterDeclaration = isTypeParameterDeclaration;\nexports.isTypeParameterInstantiation = isTypeParameterInstantiation;\nexports.isTypeScript = isTypeScript;\nexports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\nexports.isUnaryExpression = isUnaryExpression;\nexports.isUnaryLike = isUnaryLike;\nexports.isUnionTypeAnnotation = isUnionTypeAnnotation;\nexports.isUpdateExpression = isUpdateExpression;\nexports.isUserWhitespacable = isUserWhitespacable;\nexports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;\nexports.isVariableDeclaration = isVariableDeclaration;\nexports.isVariableDeclarator = isVariableDeclarator;\nexports.isVariance = isVariance;\nexports.isVoidTypeAnnotation = isVoidTypeAnnotation;\nexports.isWhile = isWhile;\nexports.isWhileStatement = isWhileStatement;\nexports.isWithStatement = isWithStatement;\nexports.isYieldExpression = isYieldExpression;\nvar _shallowEqual = require(\"../../utils/shallowEqual\");\nfunction isArrayExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ArrayExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isAssignmentExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"AssignmentExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBinaryExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BinaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isInterpreterDirective(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"InterpreterDirective\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDirective(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Directive\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDirectiveLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DirectiveLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBlockStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BlockStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBreakStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BreakStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isCallExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"CallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isCatchClause(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"CatchClause\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isConditionalExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ConditionalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isContinueStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ContinueStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDebuggerStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DebuggerStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDoWhileStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DoWhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEmptyStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EmptyStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExpressionStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExpressionStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFile(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"File\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isForInStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ForInStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isForStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ForStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFunctionDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"FunctionDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFunctionExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"FunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Identifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isIfStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"IfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isLabeledStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"LabeledStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"StringLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNumericLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NumericLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNullLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NullLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBooleanLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BooleanLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isRegExpLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"RegExpLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isLogicalExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"LogicalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"MemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNewExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NewExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isProgram(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Program\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isRestElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"RestElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isReturnStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ReturnStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isSequenceExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"SequenceExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isParenthesizedExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ParenthesizedExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isSwitchCase(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"SwitchCase\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isSwitchStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"SwitchStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isThisExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ThisExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isThrowStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ThrowStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTryStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TryStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isUnaryExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"UnaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isUpdateExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"UpdateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isVariableDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"VariableDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isVariableDeclarator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"VariableDeclarator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isWhileStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"WhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isWithStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"WithStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isAssignmentPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"AssignmentPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isArrayPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ArrayPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isArrowFunctionExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ArrowFunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExportDefaultDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExportDefaultDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExportNamedDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExportNamedDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExportSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isForOfStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ForOfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isImportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ImportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isImportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ImportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isImportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ImportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isImportSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ImportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isMetaProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"MetaProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isSpreadElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"SpreadElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isSuper(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Super\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTaggedTemplateExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TaggedTemplateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTemplateElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TemplateElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTemplateLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TemplateLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isYieldExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"YieldExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isAwaitExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"AwaitExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isImport(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Import\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBigIntLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BigIntLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isOptionalMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"OptionalMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isOptionalCallExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"OptionalCallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassAccessorProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassAccessorProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassPrivateProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassPrivateProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassPrivateMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassPrivateMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPrivateName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"PrivateName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isStaticBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"StaticBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isAnyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"AnyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isArrayTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ArrayTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBooleanTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BooleanTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BooleanLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNullLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NullLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClassImplements(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ClassImplements\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareClass(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareClass\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareInterface(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareInterface\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareModule(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareModule\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareModuleExports(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareModuleExports\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareTypeAlias(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareTypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareOpaqueType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareOpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareVariable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareVariable\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclareExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclareExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclaredPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DeclaredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExistsTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExistsTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFunctionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"FunctionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFunctionTypeParam(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"FunctionTypeParam\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isGenericTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"GenericTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isInferredPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"InferredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isInterfaceExtends(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"InterfaceExtends\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"InterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isInterfaceTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"InterfaceTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isIntersectionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"IntersectionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isMixedTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"MixedTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEmptyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EmptyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNullableTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NullableTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NumberLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNumberTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NumberTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectTypeInternalSlot(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectTypeInternalSlot\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectTypeCallProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectTypeCallProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectTypeIndexer(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectTypeIndexer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectTypeProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectTypeProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectTypeSpreadProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ObjectTypeSpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isOpaqueType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"OpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isQualifiedTypeIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"QualifiedTypeIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isStringLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"StringLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isStringTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"StringTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isSymbolTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"SymbolTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isThisTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ThisTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTupleTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TupleTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeofTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TypeofTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeAlias(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeCastExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TypeCastExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeParameter(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isUnionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"UnionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isVariance(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Variance\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isVoidTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"VoidTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumBooleanBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumBooleanBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumNumberBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumNumberBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumStringBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumStringBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumSymbolBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumSymbolBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumBooleanMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumBooleanMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumNumberMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumNumberMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumStringMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumStringMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumDefaultedMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"EnumDefaultedMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isIndexedAccessType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"IndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isOptionalIndexedAccessType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"OptionalIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXClosingElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXClosingElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXEmptyExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXEmptyExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXExpressionContainer(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXExpressionContainer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXSpreadChild(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXSpreadChild\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXMemberExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXNamespacedName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXNamespacedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXOpeningElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXOpeningElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXSpreadAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXSpreadAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXText(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXText\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXOpeningFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXOpeningFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSXClosingFragment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"JSXClosingFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNoop(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Noop\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPlaceholder(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Placeholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isV8IntrinsicIdentifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"V8IntrinsicIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isArgumentPlaceholder(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ArgumentPlaceholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBindExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"BindExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isImportAttribute(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ImportAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDecorator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"Decorator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDoExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DoExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ExportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isRecordExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"RecordExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTupleExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TupleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDecimalLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"DecimalLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isModuleExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"ModuleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTopicReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPipelineTopicExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"PipelineTopicExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPipelineBareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"PipelineBareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPipelinePrimaryTopicReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"PipelinePrimaryTopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSParameterProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSParameterProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSDeclareFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSDeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSDeclareMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSDeclareMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSQualifiedName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSQualifiedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSCallSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSCallSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSConstructSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSConstructSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSPropertySignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSPropertySignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSMethodSignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSMethodSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSIndexSignature(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSIndexSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSAnyKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSAnyKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSBooleanKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSBooleanKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSBigIntKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSBigIntKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSIntrinsicKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSIntrinsicKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSNeverKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSNeverKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSNullKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSNullKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSNumberKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSNumberKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSObjectKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSObjectKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSStringKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSStringKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSSymbolKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSSymbolKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSUndefinedKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSUndefinedKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSUnknownKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSUnknownKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSVoidKeyword(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSVoidKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSThisType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSThisType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSFunctionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSFunctionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSConstructorType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSConstructorType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypePredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypePredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeQuery(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeQuery\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSArrayType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSArrayType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTupleType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTupleType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSOptionalType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSOptionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSRestType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSRestType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSNamedTupleMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSNamedTupleMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSUnionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSUnionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSIntersectionType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSIntersectionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSConditionalType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSConditionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSInferType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSInferType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSParenthesizedType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSParenthesizedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeOperator(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeOperator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSIndexedAccessType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSMappedType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSMappedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSLiteralType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSLiteralType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSExpressionWithTypeArguments(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSExpressionWithTypeArguments\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSInterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSInterfaceBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSInterfaceBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeAliasDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeAliasDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSInstantiationExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSInstantiationExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSAsExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSAsExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSSatisfiesExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSSatisfiesExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeAssertion(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeAssertion\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSEnumDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSEnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSEnumMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSEnumMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSModuleDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSModuleDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSModuleBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSModuleBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSImportType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSImportType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSImportEqualsDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSImportEqualsDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSExternalModuleReference(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSExternalModuleReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSNonNullExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSNonNullExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSExportAssignment(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSExportAssignment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSNamespaceExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSNamespaceExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeParameter(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"TSTypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isStandardized(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ArrayExpression\" === nodeType || \"AssignmentExpression\" === nodeType || \"BinaryExpression\" === nodeType || \"InterpreterDirective\" === nodeType || \"Directive\" === nodeType || \"DirectiveLiteral\" === nodeType || \"BlockStatement\" === nodeType || \"BreakStatement\" === nodeType || \"CallExpression\" === nodeType || \"CatchClause\" === nodeType || \"ConditionalExpression\" === nodeType || \"ContinueStatement\" === nodeType || \"DebuggerStatement\" === nodeType || \"DoWhileStatement\" === nodeType || \"EmptyStatement\" === nodeType || \"ExpressionStatement\" === nodeType || \"File\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"Identifier\" === nodeType || \"IfStatement\" === nodeType || \"LabeledStatement\" === nodeType || \"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"LogicalExpression\" === nodeType || \"MemberExpression\" === nodeType || \"NewExpression\" === nodeType || \"Program\" === nodeType || \"ObjectExpression\" === nodeType || \"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType || \"RestElement\" === nodeType || \"ReturnStatement\" === nodeType || \"SequenceExpression\" === nodeType || \"ParenthesizedExpression\" === nodeType || \"SwitchCase\" === nodeType || \"SwitchStatement\" === nodeType || \"ThisExpression\" === nodeType || \"ThrowStatement\" === nodeType || \"TryStatement\" === nodeType || \"UnaryExpression\" === nodeType || \"UpdateExpression\" === nodeType || \"VariableDeclaration\" === nodeType || \"VariableDeclarator\" === nodeType || \"WhileStatement\" === nodeType || \"WithStatement\" === nodeType || \"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassBody\" === nodeType || \"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType || \"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ExportSpecifier\" === nodeType || \"ForOfStatement\" === nodeType || \"ImportDeclaration\" === nodeType || \"ImportDefaultSpecifier\" === nodeType || \"ImportNamespaceSpecifier\" === nodeType || \"ImportSpecifier\" === nodeType || \"MetaProperty\" === nodeType || \"ClassMethod\" === nodeType || \"ObjectPattern\" === nodeType || \"SpreadElement\" === nodeType || \"Super\" === nodeType || \"TaggedTemplateExpression\" === nodeType || \"TemplateElement\" === nodeType || \"TemplateLiteral\" === nodeType || \"YieldExpression\" === nodeType || \"AwaitExpression\" === nodeType || \"Import\" === nodeType || \"BigIntLiteral\" === nodeType || \"ExportNamespaceSpecifier\" === nodeType || \"OptionalMemberExpression\" === nodeType || \"OptionalCallExpression\" === nodeType || \"ClassProperty\" === nodeType || \"ClassAccessorProperty\" === nodeType || \"ClassPrivateProperty\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"PrivateName\" === nodeType || \"StaticBlock\" === nodeType || nodeType === \"Placeholder\" && (\"Identifier\" === node.expectedNode || \"StringLiteral\" === node.expectedNode || \"BlockStatement\" === node.expectedNode || \"ClassBody\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExpression(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ArrayExpression\" === nodeType || \"AssignmentExpression\" === nodeType || \"BinaryExpression\" === nodeType || \"CallExpression\" === nodeType || \"ConditionalExpression\" === nodeType || \"FunctionExpression\" === nodeType || \"Identifier\" === nodeType || \"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"LogicalExpression\" === nodeType || \"MemberExpression\" === nodeType || \"NewExpression\" === nodeType || \"ObjectExpression\" === nodeType || \"SequenceExpression\" === nodeType || \"ParenthesizedExpression\" === nodeType || \"ThisExpression\" === nodeType || \"UnaryExpression\" === nodeType || \"UpdateExpression\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassExpression\" === nodeType || \"MetaProperty\" === nodeType || \"Super\" === nodeType || \"TaggedTemplateExpression\" === nodeType || \"TemplateLiteral\" === nodeType || \"YieldExpression\" === nodeType || \"AwaitExpression\" === nodeType || \"Import\" === nodeType || \"BigIntLiteral\" === nodeType || \"OptionalMemberExpression\" === nodeType || \"OptionalCallExpression\" === nodeType || \"TypeCastExpression\" === nodeType || \"JSXElement\" === nodeType || \"JSXFragment\" === nodeType || \"BindExpression\" === nodeType || \"DoExpression\" === nodeType || \"RecordExpression\" === nodeType || \"TupleExpression\" === nodeType || \"DecimalLiteral\" === nodeType || \"ModuleExpression\" === nodeType || \"TopicReference\" === nodeType || \"PipelineTopicExpression\" === nodeType || \"PipelineBareFunction\" === nodeType || \"PipelinePrimaryTopicReference\" === nodeType || \"TSInstantiationExpression\" === nodeType || \"TSAsExpression\" === nodeType || \"TSSatisfiesExpression\" === nodeType || \"TSTypeAssertion\" === nodeType || \"TSNonNullExpression\" === nodeType || nodeType === \"Placeholder\" && (\"Expression\" === node.expectedNode || \"Identifier\" === node.expectedNode || \"StringLiteral\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBinary(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"BinaryExpression\" === nodeType || \"LogicalExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isScopable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"BlockStatement\" === nodeType || \"CatchClause\" === nodeType || \"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"Program\" === nodeType || \"ObjectMethod\" === nodeType || \"SwitchStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType || \"ForOfStatement\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"StaticBlock\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBlockParent(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"BlockStatement\" === nodeType || \"CatchClause\" === nodeType || \"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"Program\" === nodeType || \"ObjectMethod\" === nodeType || \"SwitchStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ForOfStatement\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"StaticBlock\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isBlock(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"BlockStatement\" === nodeType || \"Program\" === nodeType || \"TSModuleBlock\" === nodeType || nodeType === \"Placeholder\" && \"BlockStatement\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"BlockStatement\" === nodeType || \"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"DebuggerStatement\" === nodeType || \"DoWhileStatement\" === nodeType || \"EmptyStatement\" === nodeType || \"ExpressionStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"FunctionDeclaration\" === nodeType || \"IfStatement\" === nodeType || \"LabeledStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"SwitchStatement\" === nodeType || \"ThrowStatement\" === nodeType || \"TryStatement\" === nodeType || \"VariableDeclaration\" === nodeType || \"WhileStatement\" === nodeType || \"WithStatement\" === nodeType || \"ClassDeclaration\" === nodeType || \"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ForOfStatement\" === nodeType || \"ImportDeclaration\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType || \"EnumDeclaration\" === nodeType || \"TSDeclareFunction\" === nodeType || \"TSInterfaceDeclaration\" === nodeType || \"TSTypeAliasDeclaration\" === nodeType || \"TSEnumDeclaration\" === nodeType || \"TSModuleDeclaration\" === nodeType || \"TSImportEqualsDeclaration\" === nodeType || \"TSExportAssignment\" === nodeType || \"TSNamespaceExportDeclaration\" === nodeType || nodeType === \"Placeholder\" && (\"Statement\" === node.expectedNode || \"Declaration\" === node.expectedNode || \"BlockStatement\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTerminatorless(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"ThrowStatement\" === nodeType || \"YieldExpression\" === nodeType || \"AwaitExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isCompletionStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"BreakStatement\" === nodeType || \"ContinueStatement\" === nodeType || \"ReturnStatement\" === nodeType || \"ThrowStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isConditional(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ConditionalExpression\" === nodeType || \"IfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isLoop(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"DoWhileStatement\" === nodeType || \"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"WhileStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isWhile(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"DoWhileStatement\" === nodeType || \"WhileStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExpressionWrapper(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ExpressionStatement\" === nodeType || \"ParenthesizedExpression\" === nodeType || \"TypeCastExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFor(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ForInStatement\" === nodeType || \"ForStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isForXStatement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ForInStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFunction(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"ObjectMethod\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFunctionParent(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"ObjectMethod\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"StaticBlock\" === nodeType || \"TSModuleBlock\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPureish(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"FunctionDeclaration\" === nodeType || \"FunctionExpression\" === nodeType || \"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"ArrowFunctionExpression\" === nodeType || \"BigIntLiteral\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"FunctionDeclaration\" === nodeType || \"VariableDeclaration\" === nodeType || \"ClassDeclaration\" === nodeType || \"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ImportDeclaration\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType || \"EnumDeclaration\" === nodeType || \"TSDeclareFunction\" === nodeType || \"TSInterfaceDeclaration\" === nodeType || \"TSTypeAliasDeclaration\" === nodeType || \"TSEnumDeclaration\" === nodeType || \"TSModuleDeclaration\" === nodeType || nodeType === \"Placeholder\" && \"Declaration\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPatternLike(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"Identifier\" === nodeType || \"RestElement\" === nodeType || \"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || \"TSAsExpression\" === nodeType || \"TSSatisfiesExpression\" === nodeType || \"TSTypeAssertion\" === nodeType || \"TSNonNullExpression\" === nodeType || nodeType === \"Placeholder\" && (\"Pattern\" === node.expectedNode || \"Identifier\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isLVal(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"Identifier\" === nodeType || \"MemberExpression\" === nodeType || \"RestElement\" === nodeType || \"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || \"TSParameterProperty\" === nodeType || \"TSAsExpression\" === nodeType || \"TSSatisfiesExpression\" === nodeType || \"TSTypeAssertion\" === nodeType || \"TSNonNullExpression\" === nodeType || nodeType === \"Placeholder\" && (\"Pattern\" === node.expectedNode || \"Identifier\" === node.expectedNode)) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSEntityName(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"Identifier\" === nodeType || \"TSQualifiedName\" === nodeType || nodeType === \"Placeholder\" && \"Identifier\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"RegExpLiteral\" === nodeType || \"TemplateLiteral\" === nodeType || \"BigIntLiteral\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isImmutable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"StringLiteral\" === nodeType || \"NumericLiteral\" === nodeType || \"NullLiteral\" === nodeType || \"BooleanLiteral\" === nodeType || \"BigIntLiteral\" === nodeType || \"JSXAttribute\" === nodeType || \"JSXClosingElement\" === nodeType || \"JSXElement\" === nodeType || \"JSXExpressionContainer\" === nodeType || \"JSXSpreadChild\" === nodeType || \"JSXOpeningElement\" === nodeType || \"JSXText\" === nodeType || \"JSXFragment\" === nodeType || \"JSXOpeningFragment\" === nodeType || \"JSXClosingFragment\" === nodeType || \"DecimalLiteral\" === nodeType || nodeType === \"Placeholder\" && \"StringLiteral\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isUserWhitespacable(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType || \"ObjectTypeInternalSlot\" === nodeType || \"ObjectTypeCallProperty\" === nodeType || \"ObjectTypeIndexer\" === nodeType || \"ObjectTypeProperty\" === nodeType || \"ObjectTypeSpreadProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isMethod(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ObjectMethod\" === nodeType || \"ClassMethod\" === nodeType || \"ClassPrivateMethod\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isObjectMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isProperty(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ObjectProperty\" === nodeType || \"ClassProperty\" === nodeType || \"ClassAccessorProperty\" === nodeType || \"ClassPrivateProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isUnaryLike(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"UnaryExpression\" === nodeType || \"SpreadElement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPattern(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"AssignmentPattern\" === nodeType || \"ArrayPattern\" === nodeType || \"ObjectPattern\" === nodeType || nodeType === \"Placeholder\" && \"Pattern\" === node.expectedNode) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isClass(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isModuleDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType || \"ImportDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isExportDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ExportAllDeclaration\" === nodeType || \"ExportDefaultDeclaration\" === nodeType || \"ExportNamedDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isModuleSpecifier(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ExportSpecifier\" === nodeType || \"ImportDefaultSpecifier\" === nodeType || \"ImportNamespaceSpecifier\" === nodeType || \"ImportSpecifier\" === nodeType || \"ExportNamespaceSpecifier\" === nodeType || \"ExportDefaultSpecifier\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isAccessor(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ClassAccessorProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isPrivate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"ClassPrivateProperty\" === nodeType || \"ClassPrivateMethod\" === nodeType || \"PrivateName\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFlow(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"AnyTypeAnnotation\" === nodeType || \"ArrayTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"BooleanLiteralTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"ClassImplements\" === nodeType || \"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"DeclaredPredicate\" === nodeType || \"ExistsTypeAnnotation\" === nodeType || \"FunctionTypeAnnotation\" === nodeType || \"FunctionTypeParam\" === nodeType || \"GenericTypeAnnotation\" === nodeType || \"InferredPredicate\" === nodeType || \"InterfaceExtends\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"InterfaceTypeAnnotation\" === nodeType || \"IntersectionTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NullableTypeAnnotation\" === nodeType || \"NumberLiteralTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"ObjectTypeAnnotation\" === nodeType || \"ObjectTypeInternalSlot\" === nodeType || \"ObjectTypeCallProperty\" === nodeType || \"ObjectTypeIndexer\" === nodeType || \"ObjectTypeProperty\" === nodeType || \"ObjectTypeSpreadProperty\" === nodeType || \"OpaqueType\" === nodeType || \"QualifiedTypeIdentifier\" === nodeType || \"StringLiteralTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"TupleTypeAnnotation\" === nodeType || \"TypeofTypeAnnotation\" === nodeType || \"TypeAlias\" === nodeType || \"TypeAnnotation\" === nodeType || \"TypeCastExpression\" === nodeType || \"TypeParameter\" === nodeType || \"TypeParameterDeclaration\" === nodeType || \"TypeParameterInstantiation\" === nodeType || \"UnionTypeAnnotation\" === nodeType || \"Variance\" === nodeType || \"VoidTypeAnnotation\" === nodeType || \"EnumDeclaration\" === nodeType || \"EnumBooleanBody\" === nodeType || \"EnumNumberBody\" === nodeType || \"EnumStringBody\" === nodeType || \"EnumSymbolBody\" === nodeType || \"EnumBooleanMember\" === nodeType || \"EnumNumberMember\" === nodeType || \"EnumStringMember\" === nodeType || \"EnumDefaultedMember\" === nodeType || \"IndexedAccessType\" === nodeType || \"OptionalIndexedAccessType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFlowType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"AnyTypeAnnotation\" === nodeType || \"ArrayTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"BooleanLiteralTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"ExistsTypeAnnotation\" === nodeType || \"FunctionTypeAnnotation\" === nodeType || \"GenericTypeAnnotation\" === nodeType || \"InterfaceTypeAnnotation\" === nodeType || \"IntersectionTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NullableTypeAnnotation\" === nodeType || \"NumberLiteralTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"ObjectTypeAnnotation\" === nodeType || \"StringLiteralTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"TupleTypeAnnotation\" === nodeType || \"TypeofTypeAnnotation\" === nodeType || \"UnionTypeAnnotation\" === nodeType || \"VoidTypeAnnotation\" === nodeType || \"IndexedAccessType\" === nodeType || \"OptionalIndexedAccessType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFlowBaseAnnotation(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"AnyTypeAnnotation\" === nodeType || \"BooleanTypeAnnotation\" === nodeType || \"NullLiteralTypeAnnotation\" === nodeType || \"MixedTypeAnnotation\" === nodeType || \"EmptyTypeAnnotation\" === nodeType || \"NumberTypeAnnotation\" === nodeType || \"StringTypeAnnotation\" === nodeType || \"SymbolTypeAnnotation\" === nodeType || \"ThisTypeAnnotation\" === nodeType || \"VoidTypeAnnotation\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFlowDeclaration(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"DeclareClass\" === nodeType || \"DeclareFunction\" === nodeType || \"DeclareInterface\" === nodeType || \"DeclareModule\" === nodeType || \"DeclareModuleExports\" === nodeType || \"DeclareTypeAlias\" === nodeType || \"DeclareOpaqueType\" === nodeType || \"DeclareVariable\" === nodeType || \"DeclareExportDeclaration\" === nodeType || \"DeclareExportAllDeclaration\" === nodeType || \"InterfaceDeclaration\" === nodeType || \"OpaqueType\" === nodeType || \"TypeAlias\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isFlowPredicate(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"DeclaredPredicate\" === nodeType || \"InferredPredicate\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumBody(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"EnumBooleanBody\" === nodeType || \"EnumNumberBody\" === nodeType || \"EnumStringBody\" === nodeType || \"EnumSymbolBody\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isEnumMember(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"EnumBooleanMember\" === nodeType || \"EnumNumberMember\" === nodeType || \"EnumStringMember\" === nodeType || \"EnumDefaultedMember\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isJSX(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"JSXAttribute\" === nodeType || \"JSXClosingElement\" === nodeType || \"JSXElement\" === nodeType || \"JSXEmptyExpression\" === nodeType || \"JSXExpressionContainer\" === nodeType || \"JSXSpreadChild\" === nodeType || \"JSXIdentifier\" === nodeType || \"JSXMemberExpression\" === nodeType || \"JSXNamespacedName\" === nodeType || \"JSXOpeningElement\" === nodeType || \"JSXSpreadAttribute\" === nodeType || \"JSXText\" === nodeType || \"JSXFragment\" === nodeType || \"JSXOpeningFragment\" === nodeType || \"JSXClosingFragment\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isMiscellaneous(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"Noop\" === nodeType || \"Placeholder\" === nodeType || \"V8IntrinsicIdentifier\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTypeScript(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"TSParameterProperty\" === nodeType || \"TSDeclareFunction\" === nodeType || \"TSDeclareMethod\" === nodeType || \"TSQualifiedName\" === nodeType || \"TSCallSignatureDeclaration\" === nodeType || \"TSConstructSignatureDeclaration\" === nodeType || \"TSPropertySignature\" === nodeType || \"TSMethodSignature\" === nodeType || \"TSIndexSignature\" === nodeType || \"TSAnyKeyword\" === nodeType || \"TSBooleanKeyword\" === nodeType || \"TSBigIntKeyword\" === nodeType || \"TSIntrinsicKeyword\" === nodeType || \"TSNeverKeyword\" === nodeType || \"TSNullKeyword\" === nodeType || \"TSNumberKeyword\" === nodeType || \"TSObjectKeyword\" === nodeType || \"TSStringKeyword\" === nodeType || \"TSSymbolKeyword\" === nodeType || \"TSUndefinedKeyword\" === nodeType || \"TSUnknownKeyword\" === nodeType || \"TSVoidKeyword\" === nodeType || \"TSThisType\" === nodeType || \"TSFunctionType\" === nodeType || \"TSConstructorType\" === nodeType || \"TSTypeReference\" === nodeType || \"TSTypePredicate\" === nodeType || \"TSTypeQuery\" === nodeType || \"TSTypeLiteral\" === nodeType || \"TSArrayType\" === nodeType || \"TSTupleType\" === nodeType || \"TSOptionalType\" === nodeType || \"TSRestType\" === nodeType || \"TSNamedTupleMember\" === nodeType || \"TSUnionType\" === nodeType || \"TSIntersectionType\" === nodeType || \"TSConditionalType\" === nodeType || \"TSInferType\" === nodeType || \"TSParenthesizedType\" === nodeType || \"TSTypeOperator\" === nodeType || \"TSIndexedAccessType\" === nodeType || \"TSMappedType\" === nodeType || \"TSLiteralType\" === nodeType || \"TSExpressionWithTypeArguments\" === nodeType || \"TSInterfaceDeclaration\" === nodeType || \"TSInterfaceBody\" === nodeType || \"TSTypeAliasDeclaration\" === nodeType || \"TSInstantiationExpression\" === nodeType || \"TSAsExpression\" === nodeType || \"TSSatisfiesExpression\" === nodeType || \"TSTypeAssertion\" === nodeType || \"TSEnumDeclaration\" === nodeType || \"TSEnumMember\" === nodeType || \"TSModuleDeclaration\" === nodeType || \"TSModuleBlock\" === nodeType || \"TSImportType\" === nodeType || \"TSImportEqualsDeclaration\" === nodeType || \"TSExternalModuleReference\" === nodeType || \"TSNonNullExpression\" === nodeType || \"TSExportAssignment\" === nodeType || \"TSNamespaceExportDeclaration\" === nodeType || \"TSTypeAnnotation\" === nodeType || \"TSTypeParameterInstantiation\" === nodeType || \"TSTypeParameterDeclaration\" === nodeType || \"TSTypeParameter\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSTypeElement(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"TSCallSignatureDeclaration\" === nodeType || \"TSConstructSignatureDeclaration\" === nodeType || \"TSPropertySignature\" === nodeType || \"TSMethodSignature\" === nodeType || \"TSIndexSignature\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"TSAnyKeyword\" === nodeType || \"TSBooleanKeyword\" === nodeType || \"TSBigIntKeyword\" === nodeType || \"TSIntrinsicKeyword\" === nodeType || \"TSNeverKeyword\" === nodeType || \"TSNullKeyword\" === nodeType || \"TSNumberKeyword\" === nodeType || \"TSObjectKeyword\" === nodeType || \"TSStringKeyword\" === nodeType || \"TSSymbolKeyword\" === nodeType || \"TSUndefinedKeyword\" === nodeType || \"TSUnknownKeyword\" === nodeType || \"TSVoidKeyword\" === nodeType || \"TSThisType\" === nodeType || \"TSFunctionType\" === nodeType || \"TSConstructorType\" === nodeType || \"TSTypeReference\" === nodeType || \"TSTypePredicate\" === nodeType || \"TSTypeQuery\" === nodeType || \"TSTypeLiteral\" === nodeType || \"TSArrayType\" === nodeType || \"TSTupleType\" === nodeType || \"TSOptionalType\" === nodeType || \"TSRestType\" === nodeType || \"TSUnionType\" === nodeType || \"TSIntersectionType\" === nodeType || \"TSConditionalType\" === nodeType || \"TSInferType\" === nodeType || \"TSParenthesizedType\" === nodeType || \"TSTypeOperator\" === nodeType || \"TSIndexedAccessType\" === nodeType || \"TSMappedType\" === nodeType || \"TSLiteralType\" === nodeType || \"TSExpressionWithTypeArguments\" === nodeType || \"TSImportType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isTSBaseType(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n  if (\"TSAnyKeyword\" === nodeType || \"TSBooleanKeyword\" === nodeType || \"TSBigIntKeyword\" === nodeType || \"TSIntrinsicKeyword\" === nodeType || \"TSNeverKeyword\" === nodeType || \"TSNullKeyword\" === nodeType || \"TSNumberKeyword\" === nodeType || \"TSObjectKeyword\" === nodeType || \"TSStringKeyword\" === nodeType || \"TSSymbolKeyword\" === nodeType || \"TSUndefinedKeyword\" === nodeType || \"TSUnknownKeyword\" === nodeType || \"TSVoidKeyword\" === nodeType || \"TSThisType\" === nodeType || \"TSLiteralType\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isNumberLiteral(node, opts) {\n  console.trace(\"The node type NumberLiteral has been renamed to NumericLiteral\");\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"NumberLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isRegexLiteral(node, opts) {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"RegexLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isRestProperty(node, opts) {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"RestProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}\nfunction isSpreadProperty(node, opts) {\n  console.trace(\"The node type SpreadProperty has been renamed to SpreadElement\");\n  if (!node) return false;\n  const nodeType = node.type;\n  if (nodeType === \"SpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n  return false;\n}","map":{"version":3,"mappings":"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","names":["isArrayExpression","node","opts","nodeType","type","isAssignmentExpression","isBinaryExpression","isInterpreterDirective","isDirective","isDirectiveLiteral","isBlockStatement","isBreakStatement","isCallExpression","isCatchClause","isConditionalExpression","isContinueStatement","isDebuggerStatement","isDoWhileStatement","isEmptyStatement","isExpressionStatement","isFile","isForInStatement","isForStatement","isFunctionDeclaration","isFunctionExpression","isIdentifier","isIfStatement","isLabeledStatement","isStringLiteral","isNumericLiteral","isNullLiteral","isBooleanLiteral","isRegExpLiteral","isLogicalExpression","isMemberExpression","isNewExpression","isProgram","isObjectExpression","isObjectMethod","isObjectProperty","isRestElement","isReturnStatement","isSequenceExpression","isParenthesizedExpression","isSwitchCase","isSwitchStatement","isThisExpression","isThrowStatement","isTryStatement","isUnaryExpression","isUpdateExpression","isVariableDeclaration","isVariableDeclarator","isWhileStatement","isWithStatement","isAssignmentPattern","isArrayPattern","isArrowFunctionExpression","isClassBody","isClassExpression","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isExportSpecifier","isForOfStatement","isImportDeclaration","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","isMetaProperty","isClassMethod","isObjectPattern","isSpreadElement","isSuper","isTaggedTemplateExpression","isTemplateElement","isTemplateLiteral","isYieldExpression","isAwaitExpression","isImport","isBigIntLiteral","isExportNamespaceSpecifier","isOptionalMemberExpression","isOptionalCallExpression","isClassProperty","isClassAccessorProperty","isClassPrivateProperty","isClassPrivateMethod","isPrivateName","isStaticBlock","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isBooleanLiteralTypeAnnotation","isNullLiteralTypeAnnotation","isClassImplements","isDeclareClass","isDeclareFunction","isDeclareInterface","isDeclareModule","isDeclareModuleExports","isDeclareTypeAlias","isDeclareOpaqueType","isDeclareVariable","isDeclareExportDeclaration","isDeclareExportAllDeclaration","isDeclaredPredicate","isExistsTypeAnnotation","isFunctionTypeAnnotation","isFunctionTypeParam","isGenericTypeAnnotation","isInferredPredicate","isInterfaceExtends","isInterfaceDeclaration","isInterfaceTypeAnnotation","isIntersectionTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isNullableTypeAnnotation","isNumberLiteralTypeAnnotation","isNumberTypeAnnotation","isObjectTypeAnnotation","isObjectTypeInternalSlot","isObjectTypeCallProperty","isObjectTypeIndexer","isObjectTypeProperty","isObjectTypeSpreadProperty","isOpaqueType","isQualifiedTypeIdentifier","isStringLiteralTypeAnnotation","isStringTypeAnnotation","isSymbolTypeAnnotation","isThisTypeAnnotation","isTupleTypeAnnotation","isTypeofTypeAnnotation","isTypeAlias","isTypeAnnotation","isTypeCastExpression","isTypeParameter","isTypeParameterDeclaration","isTypeParameterInstantiation","isUnionTypeAnnotation","isVariance","isVoidTypeAnnotation","isEnumDeclaration","isEnumBooleanBody","isEnumNumberBody","isEnumStringBody","isEnumSymbolBody","isEnumBooleanMember","isEnumNumberMember","isEnumStringMember","isEnumDefaultedMember","isIndexedAccessType","isOptionalIndexedAccessType","isJSXAttribute","isJSXClosingElement","isJSXElement","isJSXEmptyExpression","isJSXExpressionContainer","isJSXSpreadChild","isJSXIdentifier","isJSXMemberExpression","isJSXNamespacedName","isJSXOpeningElement","isJSXSpreadAttribute","isJSXText","isJSXFragment","isJSXOpeningFragment","isJSXClosingFragment","isNoop","isPlaceholder","isV8IntrinsicIdentifier","isArgumentPlaceholder","isBindExpression","isImportAttribute","isDecorator","isDoExpression","isExportDefaultSpecifier","isRecordExpression","isTupleExpression","isDecimalLiteral","isModuleExpression","isTopicReference","isPipelineTopicExpression","isPipelineBareFunction","isPipelinePrimaryTopicReference","isTSParameterProperty","isTSDeclareFunction","isTSDeclareMethod","isTSQualifiedName","isTSCallSignatureDeclaration","isTSConstructSignatureDeclaration","isTSPropertySignature","isTSMethodSignature","isTSIndexSignature","isTSAnyKeyword","isTSBooleanKeyword","isTSBigIntKeyword","isTSIntrinsicKeyword","isTSNeverKeyword","isTSNullKeyword","isTSNumberKeyword","isTSObjectKeyword","isTSStringKeyword","isTSSymbolKeyword","isTSUndefinedKeyword","isTSUnknownKeyword","isTSVoidKeyword","isTSThisType","isTSFunctionType","isTSConstructorType","isTSTypeReference","isTSTypePredicate","isTSTypeQuery","isTSTypeLiteral","isTSArrayType","isTSTupleType","isTSOptionalType","isTSRestType","isTSNamedTupleMember","isTSUnionType","isTSIntersectionType","isTSConditionalType","isTSInferType","isTSParenthesizedType","isTSTypeOperator","isTSIndexedAccessType","isTSMappedType","isTSLiteralType","isTSExpressionWithTypeArguments","isTSInterfaceDeclaration","isTSInterfaceBody","isTSTypeAliasDeclaration","isTSInstantiationExpression","isTSAsExpression","isTSSatisfiesExpression","isTSTypeAssertion","isTSEnumDeclaration","isTSEnumMember","isTSModuleDeclaration","isTSModuleBlock","isTSImportType","isTSImportEqualsDeclaration","isTSExternalModuleReference","isTSNonNullExpression","isTSExportAssignment","isTSNamespaceExportDeclaration","isTSTypeAnnotation","isTSTypeParameterInstantiation","isTSTypeParameterDeclaration","isTSTypeParameter","isStandardized","expectedNode","isExpression","isBinary","isScopable","isBlockParent","isBlock","isStatement","isTerminatorless","isCompletionStatement","isConditional","isLoop","isWhile","isExpressionWrapper","isFor","isForXStatement","isFunction","isFunctionParent","isPureish","isDeclaration","isPatternLike","isLVal","isTSEntityName","isLiteral","isImmutable","isUserWhitespacable","isMethod","isObjectMember","isProperty","isUnaryLike","isPattern","isClass","isModuleDeclaration","isExportDeclaration","isModuleSpecifier","isAccessor","isPrivate","isFlow","isFlowType","isFlowBaseAnnotation","isFlowDeclaration","isFlowPredicate","isEnumBody","isEnumMember","isJSX","isMiscellaneous","isTypeScript","isTSTypeElement","isTSType","isTSBaseType","isNumberLiteral","console","trace","isRegexLiteral","isRestProperty","isSpreadProperty"],"sources":["/home/charlotte/WebApplicationProject/node_modules/@babel/types/src/validators/generated/index.ts"],"sourcesContent":["/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport shallowEqual from \"../../utils/shallowEqual\";\nimport type * as t from \"../..\";\n\nexport function isArrayExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrayExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrayExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAssignmentExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AssignmentExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AssignmentExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBinaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BinaryExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BinaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterpreterDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterpreterDirective {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterpreterDirective\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Directive {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Directive\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDirectiveLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DirectiveLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DirectiveLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBlockStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BlockStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BlockStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBreakStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BreakStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BreakStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.CallExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"CallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isCatchClause(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.CatchClause {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"CatchClause\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isConditionalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ConditionalExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ConditionalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isContinueStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ContinueStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ContinueStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDebuggerStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DebuggerStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DebuggerStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDoWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DoWhileStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DoWhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEmptyStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EmptyStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EmptyStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExpressionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExpressionStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExpressionStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFile(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.File {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"File\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForInStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForInStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ForInStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ForStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Identifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Identifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.IfStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"IfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLabeledStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.LabeledStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"LabeledStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStringLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StringLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StringLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumericLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NumericLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumericLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNullLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NullLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NullLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBooleanLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BooleanLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BooleanLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRegExpLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.RegExpLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RegExpLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLogicalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.LogicalExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"LogicalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.MemberExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"MemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNewExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NewExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NewExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isProgram(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Program {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Program\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRestElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.RestElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RestElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isReturnStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ReturnStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ReturnStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSequenceExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SequenceExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SequenceExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isParenthesizedExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ParenthesizedExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ParenthesizedExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSwitchCase(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SwitchCase {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SwitchCase\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSwitchStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SwitchStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SwitchStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isThisExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ThisExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ThisExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isThrowStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ThrowStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ThrowStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTryStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TryStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TryStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUnaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UnaryExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"UnaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUpdateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UpdateExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"UpdateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVariableDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.VariableDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"VariableDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVariableDeclarator(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.VariableDeclarator {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"VariableDeclarator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.WhileStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"WhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isWithStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.WithStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"WithStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAssignmentPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AssignmentPattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AssignmentPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArrayPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrayPattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrayPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArrowFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrowFunctionExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrowFunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportAllDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportDefaultDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportDefaultDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportDefaultDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportNamedDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportNamedDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportNamedDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForOfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForOfStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ForOfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportDefaultSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportNamespaceSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMetaProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.MetaProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"MetaProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectPattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSpreadElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SpreadElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SpreadElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSuper(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Super {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Super\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTaggedTemplateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TaggedTemplateExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TaggedTemplateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTemplateElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TemplateElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TemplateElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTemplateLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TemplateLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TemplateLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isYieldExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.YieldExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"YieldExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAwaitExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AwaitExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AwaitExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImport(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Import {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Import\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBigIntLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BigIntLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BigIntLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportNamespaceSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOptionalMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OptionalMemberExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OptionalMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOptionalCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OptionalCallExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OptionalCallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassAccessorProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassAccessorProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassAccessorProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassPrivateProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassPrivateProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassPrivateProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassPrivateMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassPrivateMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassPrivateMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPrivateName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PrivateName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PrivateName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStaticBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StaticBlock {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StaticBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAnyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AnyTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AnyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArrayTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrayTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrayTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBooleanTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BooleanTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BooleanTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBooleanLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BooleanLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BooleanLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNullLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NullLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NullLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassImplements(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassImplements {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassImplements\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareClass {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareClass\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareFunction {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareInterface(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareInterface {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareInterface\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareModule(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareModule {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareModule\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareModuleExports(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareModuleExports {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareModuleExports\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareTypeAlias {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareTypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareOpaqueType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareOpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareVariable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareVariable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareVariable\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareExportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareExportAllDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclaredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclaredPredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclaredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExistsTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExistsTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExistsTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionTypeParam(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionTypeParam {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionTypeParam\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isGenericTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.GenericTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"GenericTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInferredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InferredPredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InferredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterfaceExtends(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterfaceExtends {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterfaceExtends\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterfaceDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterfaceTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterfaceTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterfaceTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIntersectionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.IntersectionTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"IntersectionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMixedTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.MixedTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"MixedTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEmptyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EmptyTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EmptyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNullableTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NullableTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NullableTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumberLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NumberLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumberLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumberTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NumberTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumberTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeInternalSlot(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeInternalSlot {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeInternalSlot\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeCallProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeCallProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeCallProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeIndexer(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeIndexer {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeIndexer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeSpreadProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeSpreadProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeSpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OpaqueType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isQualifiedTypeIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.QualifiedTypeIdentifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"QualifiedTypeIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStringLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StringLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StringLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStringTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StringTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StringTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSymbolTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SymbolTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SymbolTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isThisTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ThisTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ThisTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTupleTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TupleTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TupleTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeofTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeofTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeofTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeAlias {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeCastExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeCastExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeCastExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeParameter {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeParameterDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeParameterInstantiation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUnionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UnionTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"UnionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVariance(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Variance {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Variance\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVoidTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.VoidTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"VoidTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumBooleanBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumBooleanBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumBooleanBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumNumberBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumNumberBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumNumberBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumStringBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumStringBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumStringBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumSymbolBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumSymbolBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumSymbolBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumBooleanMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumBooleanMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumBooleanMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumNumberMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumNumberMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumNumberMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumStringMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumStringMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumStringMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumDefaultedMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumDefaultedMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumDefaultedMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.IndexedAccessType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"IndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOptionalIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OptionalIndexedAccessType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OptionalIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXAttribute {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXClosingElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXClosingElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXClosingElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXEmptyExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXEmptyExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXEmptyExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXExpressionContainer(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXExpressionContainer {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXExpressionContainer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXSpreadChild(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXSpreadChild {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXSpreadChild\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXIdentifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXMemberExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXNamespacedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXNamespacedName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXNamespacedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXOpeningElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXOpeningElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXOpeningElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXSpreadAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXSpreadAttribute {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXSpreadAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXText(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXText {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXText\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXFragment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXOpeningFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXOpeningFragment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXOpeningFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXClosingFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXClosingFragment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXClosingFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Noop {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Noop\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Placeholder {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Placeholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isV8IntrinsicIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.V8IntrinsicIdentifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"V8IntrinsicIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArgumentPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArgumentPlaceholder {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArgumentPlaceholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBindExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BindExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BindExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportAttribute {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDecorator(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Decorator {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Decorator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDoExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DoExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DoExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportDefaultSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRecordExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.RecordExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RecordExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTupleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TupleExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TupleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDecimalLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DecimalLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DecimalLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isModuleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ModuleExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ModuleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TopicReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPipelineTopicExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PipelineTopicExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PipelineTopicExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPipelineBareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PipelineBareFunction {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PipelineBareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPipelinePrimaryTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PipelinePrimaryTopicReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PipelinePrimaryTopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSParameterProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSParameterProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSParameterProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSDeclareFunction {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSDeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSDeclareMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSDeclareMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSDeclareMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSQualifiedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSQualifiedName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSQualifiedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSCallSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSCallSignatureDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSCallSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSConstructSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSConstructSignatureDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSConstructSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSPropertySignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSPropertySignature {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSPropertySignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSMethodSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSMethodSignature {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSMethodSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIndexSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIndexSignature {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIndexSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSAnyKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSAnyKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSAnyKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSBooleanKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSBooleanKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSBooleanKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSBigIntKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSBigIntKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSBigIntKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIntrinsicKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIntrinsicKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIntrinsicKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNeverKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNeverKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNeverKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNullKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNullKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNullKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNumberKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNumberKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNumberKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSObjectKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSObjectKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSObjectKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSStringKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSStringKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSStringKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSSymbolKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSSymbolKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSSymbolKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSUndefinedKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSUndefinedKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSUndefinedKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSUnknownKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSUnknownKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSUnknownKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSVoidKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSVoidKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSVoidKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSThisType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSThisType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSThisType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSFunctionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSFunctionType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSFunctionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSConstructorType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSConstructorType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSConstructorType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypePredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypePredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypePredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeQuery(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeQuery {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeQuery\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSArrayType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSArrayType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSArrayType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTupleType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTupleType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTupleType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSOptionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSOptionalType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSOptionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSRestType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSRestType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSRestType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNamedTupleMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNamedTupleMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNamedTupleMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSUnionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSUnionType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSUnionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIntersectionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIntersectionType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIntersectionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSConditionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSConditionalType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSConditionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInferType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInferType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInferType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSParenthesizedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSParenthesizedType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSParenthesizedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeOperator(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeOperator {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeOperator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIndexedAccessType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSMappedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSMappedType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSMappedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSLiteralType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSLiteralType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSLiteralType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSExpressionWithTypeArguments(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSExpressionWithTypeArguments {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSExpressionWithTypeArguments\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInterfaceDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInterfaceBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInterfaceBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInterfaceBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeAliasDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeAliasDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeAliasDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInstantiationExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInstantiationExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInstantiationExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSAsExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSAsExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSAsExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSSatisfiesExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSSatisfiesExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSSatisfiesExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeAssertion(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeAssertion {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeAssertion\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSEnumDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSEnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSEnumMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSEnumMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSModuleDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSModuleDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSModuleDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSModuleBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSModuleBlock {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSModuleBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSImportType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSImportType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSImportType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSImportEqualsDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSImportEqualsDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSImportEqualsDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSExternalModuleReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSExternalModuleReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSExternalModuleReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNonNullExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNonNullExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNonNullExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSExportAssignment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSExportAssignment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSExportAssignment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNamespaceExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNamespaceExportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNamespaceExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeParameterInstantiation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeParameterDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeParameter {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStandardized(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Standardized {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ArrayExpression\" === nodeType ||\n    \"AssignmentExpression\" === nodeType ||\n    \"BinaryExpression\" === nodeType ||\n    \"InterpreterDirective\" === nodeType ||\n    \"Directive\" === nodeType ||\n    \"DirectiveLiteral\" === nodeType ||\n    \"BlockStatement\" === nodeType ||\n    \"BreakStatement\" === nodeType ||\n    \"CallExpression\" === nodeType ||\n    \"CatchClause\" === nodeType ||\n    \"ConditionalExpression\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"DebuggerStatement\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"EmptyStatement\" === nodeType ||\n    \"ExpressionStatement\" === nodeType ||\n    \"File\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Identifier\" === nodeType ||\n    \"IfStatement\" === nodeType ||\n    \"LabeledStatement\" === nodeType ||\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"LogicalExpression\" === nodeType ||\n    \"MemberExpression\" === nodeType ||\n    \"NewExpression\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"ObjectExpression\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"ObjectProperty\" === nodeType ||\n    \"RestElement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"SequenceExpression\" === nodeType ||\n    \"ParenthesizedExpression\" === nodeType ||\n    \"SwitchCase\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"ThisExpression\" === nodeType ||\n    \"ThrowStatement\" === nodeType ||\n    \"TryStatement\" === nodeType ||\n    \"UnaryExpression\" === nodeType ||\n    \"UpdateExpression\" === nodeType ||\n    \"VariableDeclaration\" === nodeType ||\n    \"VariableDeclarator\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"WithStatement\" === nodeType ||\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassBody\" === nodeType ||\n    \"ClassExpression\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ExportSpecifier\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ImportDeclaration\" === nodeType ||\n    \"ImportDefaultSpecifier\" === nodeType ||\n    \"ImportNamespaceSpecifier\" === nodeType ||\n    \"ImportSpecifier\" === nodeType ||\n    \"MetaProperty\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    \"SpreadElement\" === nodeType ||\n    \"Super\" === nodeType ||\n    \"TaggedTemplateExpression\" === nodeType ||\n    \"TemplateElement\" === nodeType ||\n    \"TemplateLiteral\" === nodeType ||\n    \"YieldExpression\" === nodeType ||\n    \"AwaitExpression\" === nodeType ||\n    \"Import\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"ExportNamespaceSpecifier\" === nodeType ||\n    \"OptionalMemberExpression\" === nodeType ||\n    \"OptionalCallExpression\" === nodeType ||\n    \"ClassProperty\" === nodeType ||\n    \"ClassAccessorProperty\" === nodeType ||\n    \"ClassPrivateProperty\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"PrivateName\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Identifier\" === (node as t.Placeholder).expectedNode ||\n        \"StringLiteral\" === (node as t.Placeholder).expectedNode ||\n        \"BlockStatement\" === (node as t.Placeholder).expectedNode ||\n        \"ClassBody\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Expression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ArrayExpression\" === nodeType ||\n    \"AssignmentExpression\" === nodeType ||\n    \"BinaryExpression\" === nodeType ||\n    \"CallExpression\" === nodeType ||\n    \"ConditionalExpression\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Identifier\" === nodeType ||\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"LogicalExpression\" === nodeType ||\n    \"MemberExpression\" === nodeType ||\n    \"NewExpression\" === nodeType ||\n    \"ObjectExpression\" === nodeType ||\n    \"SequenceExpression\" === nodeType ||\n    \"ParenthesizedExpression\" === nodeType ||\n    \"ThisExpression\" === nodeType ||\n    \"UnaryExpression\" === nodeType ||\n    \"UpdateExpression\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassExpression\" === nodeType ||\n    \"MetaProperty\" === nodeType ||\n    \"Super\" === nodeType ||\n    \"TaggedTemplateExpression\" === nodeType ||\n    \"TemplateLiteral\" === nodeType ||\n    \"YieldExpression\" === nodeType ||\n    \"AwaitExpression\" === nodeType ||\n    \"Import\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"OptionalMemberExpression\" === nodeType ||\n    \"OptionalCallExpression\" === nodeType ||\n    \"TypeCastExpression\" === nodeType ||\n    \"JSXElement\" === nodeType ||\n    \"JSXFragment\" === nodeType ||\n    \"BindExpression\" === nodeType ||\n    \"DoExpression\" === nodeType ||\n    \"RecordExpression\" === nodeType ||\n    \"TupleExpression\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    \"ModuleExpression\" === nodeType ||\n    \"TopicReference\" === nodeType ||\n    \"PipelineTopicExpression\" === nodeType ||\n    \"PipelineBareFunction\" === nodeType ||\n    \"PipelinePrimaryTopicReference\" === nodeType ||\n    \"TSInstantiationExpression\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Expression\" === (node as t.Placeholder).expectedNode ||\n        \"Identifier\" === (node as t.Placeholder).expectedNode ||\n        \"StringLiteral\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBinary(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Binary {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"BinaryExpression\" === nodeType || \"LogicalExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isScopable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Scopable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"CatchClause\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassExpression\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"BlockStatement\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBlockParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BlockParent {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"CatchClause\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"BlockStatement\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Block {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"BlockStatement\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Statement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"BreakStatement\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"DebuggerStatement\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"EmptyStatement\" === nodeType ||\n    \"ExpressionStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"IfStatement\" === nodeType ||\n    \"LabeledStatement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"ThrowStatement\" === nodeType ||\n    \"TryStatement\" === nodeType ||\n    \"VariableDeclaration\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"WithStatement\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ImportDeclaration\" === nodeType ||\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"TypeAlias\" === nodeType ||\n    \"EnumDeclaration\" === nodeType ||\n    \"TSDeclareFunction\" === nodeType ||\n    \"TSInterfaceDeclaration\" === nodeType ||\n    \"TSTypeAliasDeclaration\" === nodeType ||\n    \"TSEnumDeclaration\" === nodeType ||\n    \"TSModuleDeclaration\" === nodeType ||\n    \"TSImportEqualsDeclaration\" === nodeType ||\n    \"TSExportAssignment\" === nodeType ||\n    \"TSNamespaceExportDeclaration\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Statement\" === (node as t.Placeholder).expectedNode ||\n        \"Declaration\" === (node as t.Placeholder).expectedNode ||\n        \"BlockStatement\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTerminatorless(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Terminatorless {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BreakStatement\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"ThrowStatement\" === nodeType ||\n    \"YieldExpression\" === nodeType ||\n    \"AwaitExpression\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isCompletionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.CompletionStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BreakStatement\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"ThrowStatement\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isConditional(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Conditional {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ConditionalExpression\" === nodeType || \"IfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Loop {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"DoWhileStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"ForOfStatement\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isWhile(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.While {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"DoWhileStatement\" === nodeType || \"WhileStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExpressionWrapper(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExpressionWrapper {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExpressionStatement\" === nodeType ||\n    \"ParenthesizedExpression\" === nodeType ||\n    \"TypeCastExpression\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFor(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.For {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"ForOfStatement\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForXStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForXStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ForInStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Function {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionParent {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    \"TSModuleBlock\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPureish(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Pureish {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"StringLiteral\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Declaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"VariableDeclaration\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ImportDeclaration\" === nodeType ||\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"TypeAlias\" === nodeType ||\n    \"EnumDeclaration\" === nodeType ||\n    \"TSDeclareFunction\" === nodeType ||\n    \"TSInterfaceDeclaration\" === nodeType ||\n    \"TSTypeAliasDeclaration\" === nodeType ||\n    \"TSEnumDeclaration\" === nodeType ||\n    \"TSModuleDeclaration\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"Declaration\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPatternLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PatternLike {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Identifier\" === nodeType ||\n    \"RestElement\" === nodeType ||\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Pattern\" === (node as t.Placeholder).expectedNode ||\n        \"Identifier\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLVal(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.LVal {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Identifier\" === nodeType ||\n    \"MemberExpression\" === nodeType ||\n    \"RestElement\" === nodeType ||\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    \"TSParameterProperty\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Pattern\" === (node as t.Placeholder).expectedNode ||\n        \"Identifier\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSEntityName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSEntityName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Identifier\" === nodeType ||\n    \"TSQualifiedName\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"Identifier\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Literal {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"TemplateLiteral\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"StringLiteral\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImmutable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Immutable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"JSXAttribute\" === nodeType ||\n    \"JSXClosingElement\" === nodeType ||\n    \"JSXElement\" === nodeType ||\n    \"JSXExpressionContainer\" === nodeType ||\n    \"JSXSpreadChild\" === nodeType ||\n    \"JSXOpeningElement\" === nodeType ||\n    \"JSXText\" === nodeType ||\n    \"JSXFragment\" === nodeType ||\n    \"JSXOpeningFragment\" === nodeType ||\n    \"JSXClosingFragment\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"StringLiteral\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUserWhitespacable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UserWhitespacable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ObjectMethod\" === nodeType ||\n    \"ObjectProperty\" === nodeType ||\n    \"ObjectTypeInternalSlot\" === nodeType ||\n    \"ObjectTypeCallProperty\" === nodeType ||\n    \"ObjectTypeIndexer\" === nodeType ||\n    \"ObjectTypeProperty\" === nodeType ||\n    \"ObjectTypeSpreadProperty\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Method {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ObjectMethod\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Property {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ObjectProperty\" === nodeType ||\n    \"ClassProperty\" === nodeType ||\n    \"ClassAccessorProperty\" === nodeType ||\n    \"ClassPrivateProperty\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUnaryLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UnaryLike {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"UnaryExpression\" === nodeType || \"SpreadElement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Pattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"Pattern\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Class {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isModuleDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ModuleDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ImportDeclaration\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isModuleSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ModuleSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExportSpecifier\" === nodeType ||\n    \"ImportDefaultSpecifier\" === nodeType ||\n    \"ImportNamespaceSpecifier\" === nodeType ||\n    \"ImportSpecifier\" === nodeType ||\n    \"ExportNamespaceSpecifier\" === nodeType ||\n    \"ExportDefaultSpecifier\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAccessor(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Accessor {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ClassAccessorProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPrivate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Private {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ClassPrivateProperty\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"PrivateName\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlow(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Flow {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AnyTypeAnnotation\" === nodeType ||\n    \"ArrayTypeAnnotation\" === nodeType ||\n    \"BooleanTypeAnnotation\" === nodeType ||\n    \"BooleanLiteralTypeAnnotation\" === nodeType ||\n    \"NullLiteralTypeAnnotation\" === nodeType ||\n    \"ClassImplements\" === nodeType ||\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"DeclaredPredicate\" === nodeType ||\n    \"ExistsTypeAnnotation\" === nodeType ||\n    \"FunctionTypeAnnotation\" === nodeType ||\n    \"FunctionTypeParam\" === nodeType ||\n    \"GenericTypeAnnotation\" === nodeType ||\n    \"InferredPredicate\" === nodeType ||\n    \"InterfaceExtends\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"InterfaceTypeAnnotation\" === nodeType ||\n    \"IntersectionTypeAnnotation\" === nodeType ||\n    \"MixedTypeAnnotation\" === nodeType ||\n    \"EmptyTypeAnnotation\" === nodeType ||\n    \"NullableTypeAnnotation\" === nodeType ||\n    \"NumberLiteralTypeAnnotation\" === nodeType ||\n    \"NumberTypeAnnotation\" === nodeType ||\n    \"ObjectTypeAnnotation\" === nodeType ||\n    \"ObjectTypeInternalSlot\" === nodeType ||\n    \"ObjectTypeCallProperty\" === nodeType ||\n    \"ObjectTypeIndexer\" === nodeType ||\n    \"ObjectTypeProperty\" === nodeType ||\n    \"ObjectTypeSpreadProperty\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"QualifiedTypeIdentifier\" === nodeType ||\n    \"StringLiteralTypeAnnotation\" === nodeType ||\n    \"StringTypeAnnotation\" === nodeType ||\n    \"SymbolTypeAnnotation\" === nodeType ||\n    \"ThisTypeAnnotation\" === nodeType ||\n    \"TupleTypeAnnotation\" === nodeType ||\n    \"TypeofTypeAnnotation\" === nodeType ||\n    \"TypeAlias\" === nodeType ||\n    \"TypeAnnotation\" === nodeType ||\n    \"TypeCastExpression\" === nodeType ||\n    \"TypeParameter\" === nodeType ||\n    \"TypeParameterDeclaration\" === nodeType ||\n    \"TypeParameterInstantiation\" === nodeType ||\n    \"UnionTypeAnnotation\" === nodeType ||\n    \"Variance\" === nodeType ||\n    \"VoidTypeAnnotation\" === nodeType ||\n    \"EnumDeclaration\" === nodeType ||\n    \"EnumBooleanBody\" === nodeType ||\n    \"EnumNumberBody\" === nodeType ||\n    \"EnumStringBody\" === nodeType ||\n    \"EnumSymbolBody\" === nodeType ||\n    \"EnumBooleanMember\" === nodeType ||\n    \"EnumNumberMember\" === nodeType ||\n    \"EnumStringMember\" === nodeType ||\n    \"EnumDefaultedMember\" === nodeType ||\n    \"IndexedAccessType\" === nodeType ||\n    \"OptionalIndexedAccessType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AnyTypeAnnotation\" === nodeType ||\n    \"ArrayTypeAnnotation\" === nodeType ||\n    \"BooleanTypeAnnotation\" === nodeType ||\n    \"BooleanLiteralTypeAnnotation\" === nodeType ||\n    \"NullLiteralTypeAnnotation\" === nodeType ||\n    \"ExistsTypeAnnotation\" === nodeType ||\n    \"FunctionTypeAnnotation\" === nodeType ||\n    \"GenericTypeAnnotation\" === nodeType ||\n    \"InterfaceTypeAnnotation\" === nodeType ||\n    \"IntersectionTypeAnnotation\" === nodeType ||\n    \"MixedTypeAnnotation\" === nodeType ||\n    \"EmptyTypeAnnotation\" === nodeType ||\n    \"NullableTypeAnnotation\" === nodeType ||\n    \"NumberLiteralTypeAnnotation\" === nodeType ||\n    \"NumberTypeAnnotation\" === nodeType ||\n    \"ObjectTypeAnnotation\" === nodeType ||\n    \"StringLiteralTypeAnnotation\" === nodeType ||\n    \"StringTypeAnnotation\" === nodeType ||\n    \"SymbolTypeAnnotation\" === nodeType ||\n    \"ThisTypeAnnotation\" === nodeType ||\n    \"TupleTypeAnnotation\" === nodeType ||\n    \"TypeofTypeAnnotation\" === nodeType ||\n    \"UnionTypeAnnotation\" === nodeType ||\n    \"VoidTypeAnnotation\" === nodeType ||\n    \"IndexedAccessType\" === nodeType ||\n    \"OptionalIndexedAccessType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowBaseAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowBaseAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AnyTypeAnnotation\" === nodeType ||\n    \"BooleanTypeAnnotation\" === nodeType ||\n    \"NullLiteralTypeAnnotation\" === nodeType ||\n    \"MixedTypeAnnotation\" === nodeType ||\n    \"EmptyTypeAnnotation\" === nodeType ||\n    \"NumberTypeAnnotation\" === nodeType ||\n    \"StringTypeAnnotation\" === nodeType ||\n    \"SymbolTypeAnnotation\" === nodeType ||\n    \"ThisTypeAnnotation\" === nodeType ||\n    \"VoidTypeAnnotation\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"TypeAlias\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowPredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"DeclaredPredicate\" === nodeType || \"InferredPredicate\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"EnumBooleanBody\" === nodeType ||\n    \"EnumNumberBody\" === nodeType ||\n    \"EnumStringBody\" === nodeType ||\n    \"EnumSymbolBody\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"EnumBooleanMember\" === nodeType ||\n    \"EnumNumberMember\" === nodeType ||\n    \"EnumStringMember\" === nodeType ||\n    \"EnumDefaultedMember\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSX(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSX {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"JSXAttribute\" === nodeType ||\n    \"JSXClosingElement\" === nodeType ||\n    \"JSXElement\" === nodeType ||\n    \"JSXEmptyExpression\" === nodeType ||\n    \"JSXExpressionContainer\" === nodeType ||\n    \"JSXSpreadChild\" === nodeType ||\n    \"JSXIdentifier\" === nodeType ||\n    \"JSXMemberExpression\" === nodeType ||\n    \"JSXNamespacedName\" === nodeType ||\n    \"JSXOpeningElement\" === nodeType ||\n    \"JSXSpreadAttribute\" === nodeType ||\n    \"JSXText\" === nodeType ||\n    \"JSXFragment\" === nodeType ||\n    \"JSXOpeningFragment\" === nodeType ||\n    \"JSXClosingFragment\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMiscellaneous(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Miscellaneous {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Noop\" === nodeType ||\n    \"Placeholder\" === nodeType ||\n    \"V8IntrinsicIdentifier\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeScript(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeScript {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSParameterProperty\" === nodeType ||\n    \"TSDeclareFunction\" === nodeType ||\n    \"TSDeclareMethod\" === nodeType ||\n    \"TSQualifiedName\" === nodeType ||\n    \"TSCallSignatureDeclaration\" === nodeType ||\n    \"TSConstructSignatureDeclaration\" === nodeType ||\n    \"TSPropertySignature\" === nodeType ||\n    \"TSMethodSignature\" === nodeType ||\n    \"TSIndexSignature\" === nodeType ||\n    \"TSAnyKeyword\" === nodeType ||\n    \"TSBooleanKeyword\" === nodeType ||\n    \"TSBigIntKeyword\" === nodeType ||\n    \"TSIntrinsicKeyword\" === nodeType ||\n    \"TSNeverKeyword\" === nodeType ||\n    \"TSNullKeyword\" === nodeType ||\n    \"TSNumberKeyword\" === nodeType ||\n    \"TSObjectKeyword\" === nodeType ||\n    \"TSStringKeyword\" === nodeType ||\n    \"TSSymbolKeyword\" === nodeType ||\n    \"TSUndefinedKeyword\" === nodeType ||\n    \"TSUnknownKeyword\" === nodeType ||\n    \"TSVoidKeyword\" === nodeType ||\n    \"TSThisType\" === nodeType ||\n    \"TSFunctionType\" === nodeType ||\n    \"TSConstructorType\" === nodeType ||\n    \"TSTypeReference\" === nodeType ||\n    \"TSTypePredicate\" === nodeType ||\n    \"TSTypeQuery\" === nodeType ||\n    \"TSTypeLiteral\" === nodeType ||\n    \"TSArrayType\" === nodeType ||\n    \"TSTupleType\" === nodeType ||\n    \"TSOptionalType\" === nodeType ||\n    \"TSRestType\" === nodeType ||\n    \"TSNamedTupleMember\" === nodeType ||\n    \"TSUnionType\" === nodeType ||\n    \"TSIntersectionType\" === nodeType ||\n    \"TSConditionalType\" === nodeType ||\n    \"TSInferType\" === nodeType ||\n    \"TSParenthesizedType\" === nodeType ||\n    \"TSTypeOperator\" === nodeType ||\n    \"TSIndexedAccessType\" === nodeType ||\n    \"TSMappedType\" === nodeType ||\n    \"TSLiteralType\" === nodeType ||\n    \"TSExpressionWithTypeArguments\" === nodeType ||\n    \"TSInterfaceDeclaration\" === nodeType ||\n    \"TSInterfaceBody\" === nodeType ||\n    \"TSTypeAliasDeclaration\" === nodeType ||\n    \"TSInstantiationExpression\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSEnumDeclaration\" === nodeType ||\n    \"TSEnumMember\" === nodeType ||\n    \"TSModuleDeclaration\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    \"TSImportType\" === nodeType ||\n    \"TSImportEqualsDeclaration\" === nodeType ||\n    \"TSExternalModuleReference\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    \"TSExportAssignment\" === nodeType ||\n    \"TSNamespaceExportDeclaration\" === nodeType ||\n    \"TSTypeAnnotation\" === nodeType ||\n    \"TSTypeParameterInstantiation\" === nodeType ||\n    \"TSTypeParameterDeclaration\" === nodeType ||\n    \"TSTypeParameter\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSCallSignatureDeclaration\" === nodeType ||\n    \"TSConstructSignatureDeclaration\" === nodeType ||\n    \"TSPropertySignature\" === nodeType ||\n    \"TSMethodSignature\" === nodeType ||\n    \"TSIndexSignature\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSAnyKeyword\" === nodeType ||\n    \"TSBooleanKeyword\" === nodeType ||\n    \"TSBigIntKeyword\" === nodeType ||\n    \"TSIntrinsicKeyword\" === nodeType ||\n    \"TSNeverKeyword\" === nodeType ||\n    \"TSNullKeyword\" === nodeType ||\n    \"TSNumberKeyword\" === nodeType ||\n    \"TSObjectKeyword\" === nodeType ||\n    \"TSStringKeyword\" === nodeType ||\n    \"TSSymbolKeyword\" === nodeType ||\n    \"TSUndefinedKeyword\" === nodeType ||\n    \"TSUnknownKeyword\" === nodeType ||\n    \"TSVoidKeyword\" === nodeType ||\n    \"TSThisType\" === nodeType ||\n    \"TSFunctionType\" === nodeType ||\n    \"TSConstructorType\" === nodeType ||\n    \"TSTypeReference\" === nodeType ||\n    \"TSTypePredicate\" === nodeType ||\n    \"TSTypeQuery\" === nodeType ||\n    \"TSTypeLiteral\" === nodeType ||\n    \"TSArrayType\" === nodeType ||\n    \"TSTupleType\" === nodeType ||\n    \"TSOptionalType\" === nodeType ||\n    \"TSRestType\" === nodeType ||\n    \"TSUnionType\" === nodeType ||\n    \"TSIntersectionType\" === nodeType ||\n    \"TSConditionalType\" === nodeType ||\n    \"TSInferType\" === nodeType ||\n    \"TSParenthesizedType\" === nodeType ||\n    \"TSTypeOperator\" === nodeType ||\n    \"TSIndexedAccessType\" === nodeType ||\n    \"TSMappedType\" === nodeType ||\n    \"TSLiteralType\" === nodeType ||\n    \"TSExpressionWithTypeArguments\" === nodeType ||\n    \"TSImportType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSBaseType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSBaseType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSAnyKeyword\" === nodeType ||\n    \"TSBooleanKeyword\" === nodeType ||\n    \"TSBigIntKeyword\" === nodeType ||\n    \"TSIntrinsicKeyword\" === nodeType ||\n    \"TSNeverKeyword\" === nodeType ||\n    \"TSNullKeyword\" === nodeType ||\n    \"TSNumberKeyword\" === nodeType ||\n    \"TSObjectKeyword\" === nodeType ||\n    \"TSStringKeyword\" === nodeType ||\n    \"TSSymbolKeyword\" === nodeType ||\n    \"TSUndefinedKeyword\" === nodeType ||\n    \"TSUnknownKeyword\" === nodeType ||\n    \"TSVoidKeyword\" === nodeType ||\n    \"TSThisType\" === nodeType ||\n    \"TSLiteralType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumberLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  console.trace(\n    \"The node type NumberLiteral has been renamed to NumericLiteral\",\n  );\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumberLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRegexLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  console.trace(\"The node type RegexLiteral has been renamed to RegExpLiteral\");\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RegexLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRestProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  console.trace(\"The node type RestProperty has been renamed to RestElement\");\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RestProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSpreadProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  console.trace(\n    \"The node type SpreadProperty has been renamed to SpreadElement\",\n  );\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}